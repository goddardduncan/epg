<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="https://epg.dunc.app/favicon.ico" type="image/x-icon">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live TV</title>

    <style>
        html, body, #video-container {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        #video {
            width: 100%;
            height: 100%;
        }

        #video-description {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            background-color: rgba(0,0,0,0.5);
            color: #fff;
            padding: 10px;
            text-align: center;
            font-size: 1.5em;
            font-family: 'Roboto', sans-serif;
            box-sizing: border-box;
            display: none;
        }

        /* Optional small debug label (disabled by default) */
        #channel-source-debug {
            position: absolute;
            top: 5px;
            right: 10px;
            background: rgba(0,0,0,0.4);
            padding: 4px 8px;
            color: #fff;
            font-size: 12px;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="video" autoplay controls></video>
        <div id="video-description"></div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <script>
        const channelSourceKey = 'channelSource';
        const channelSource = localStorage.getItem(channelSourceKey) || 'channels.json';

        // --- NEW CLICK LOGIC & SUBTITLE CONFIGURATION ---
        const DOUBLE_CLICK_TIME_MS = 500; // 0.5 seconds time window
        const STANDBY_URL = 'https://dj.dunc.app/control/standby';
        const ON_URL = 'https://dj.dunc.app/control/epg';
        const NAVIGATE_TO_URL = 'https://epg.dunc.app/';

        // --- NEW CLICK LOGIC STATE VARIABLES ---
        let lastContextMenuTimestamp = 0;
        let contextMenuTimer = null;
        const video = document.getElementById('video');

        // --- Subtitle Toggle Function (Now separate) ---
        function toggleSubtitles() {
            const tracks = video.textTracks;
            for (let t of tracks) {
                if (t.kind === 'subtitles' || t.kind === 'captions') {
                    t.mode = t.mode === 'showing' ? 'hidden' : 'showing';
                }
            }
        }

        // --- ON/STANDBY Request Sender Function ---
        async function sendRequest(url, commandName) {
            try {
                const response = await fetch(url, {
                    method: 'POST',
                });
                if (response.ok) {
                    console.log(`${commandName} command sent successfully.`);
                } else {
                    console.error(`Failed to send ${commandName} command. Status: ${response.status}`);
                }
            } catch (error) {
                console.error(`Error sending ${commandName} request:`, error);
            }
        }

        // --- Context Menu Handler (Master Logic) ---
        async function handleContextMenu(event) {
            // 1. Always prevent the default browser context menu
            event.preventDefault();

            const currentTime = Date.now();
            const timeSinceLastClick = currentTime - lastContextMenuTimestamp;

            // 2. Check for **Double-Click** (Standby)
            if (timeSinceLastClick < DOUBLE_CLICK_TIME_MS) {
                // DOUBLE-CLICK DETECTED: Fire Standby Command

                // Clear the pending single-click (On) action
                clearTimeout(contextMenuTimer);
                contextMenuTimer = null;
                lastContextMenuTimestamp = 0; // Reset timestamp

                console.log('Double-click detected. Triggering Standby.');
                await sendRequest(STANDBY_URL, 'Standby');

            } else {
                // FIRST CLICK: Trigger Subtitle Toggle immediately and set up the 'On' timer

                // A. Immediate Action: Toggle Subtitles
                toggleSubtitles(); 

                // B. Delayed Action: Set up Single-Click Timer (On Request & Navigate)

                // Clear any previous timer just in case
                if (contextMenuTimer) {
                     clearTimeout(contextMenuTimer);
                }

                // Set a timer for the single-click action
                contextMenuTimer = setTimeout(async () => {
                    // This executes if a second click does NOT happen in time (single-click confirmed)
                    console.log('Single-click confirmed. Triggering ON and Navigation.');
                    await sendRequest(ON_URL, 'On');

                    console.log(`Navigating to: ${NAVIGATE_TO_URL}`);
                    window.location.href = NAVIGATE_TO_URL;

                    // Reset the timer and timestamp after execution
                    contextMenuTimer = null;
                    lastContextMenuTimestamp = 0;
                }, DOUBLE_CLICK_TIME_MS);

                // Update the timestamp for the first click
                lastContextMenuTimestamp = currentTime;
            }
        }

        // --- Attach the new master handler to the document's contextmenu event ---
        document.addEventListener("contextmenu", handleContextMenu);

        // --- Original Functions Follow ---

        async function loadChannelOrder() {
            // ... (Rest of function)
            try {
                const response = await fetch('channelorder.json');
                if (!response.ok) throw new Error('Channel order load error');
                return await response.json();
            } catch (e) {
                console.error('Failed to load channelorder.json:', e);
                return [];
            }
        }

        async function loadChannelLinkMap() {
            // ... (Rest of function)
            try {
                const response = await fetch(channelSource);
                if (!response.ok) throw new Error('Link map load error');
                const map = await response.json();
                console.log('Loaded links from', channelSource);
                return map;
            } catch (e) {
                console.error('Failed to load channel link map:', e);
                return {};
            }
        }

        function getUrlParameter(name) {
            // ... (Rest of function)
            const regex = new RegExp('[?&]' + name + '=([^&#]*)');
            const result = regex.exec(location.search);
            return result ? decodeURIComponent(result[1]) : '';
        }

        function getUrlParameterCheck(name, url) {
            // ... (Rest of function)
            const base = 'https://goddardduncan.github.io/epg/';
            return url.slice(url.indexOf(base) + base.length);
        }

        async function loadAndPlayStream(url) {
            // ... (Rest of function)
            if (Hls.isSupported()) {
                const hls = new Hls();
                hls.loadSource(url);
                hls.attachMedia(video);
                hls.on(Hls.Events.MANIFEST_PARSED, () => video.play());
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = url;
                video.play();
            } else {
                alert("HLS playback not supported.");
            }
        }

        function disableSubtitles() {
            // ... (Rest of function)
            const tracks = video.textTracks;
            let found = false;

            for (let t of tracks) {
                if (t.kind === 'subtitles' || t.kind === 'captions') {
                    t.mode = 'hidden';
                    found = true;
                }
            }
            return found;
        }

        document.addEventListener("DOMContentLoaded", async () => {

            const channelsOrder = await loadChannelOrder();
            const channelLinkMap = await loadChannelLinkMap();

            const urlParameter = getUrlParameter('url');
            const streamKey = getUrlParameter('stream');
            const urlCheck = getUrlParameterCheck('url', location.href);

            if (urlParameter) {
                loadAndPlayStream(urlParameter);

            } else if (streamKey) {
                const stored = JSON.parse(localStorage.getItem('m3u8Files') || '{}');
                if (stored[streamKey]) {
                    const blob = new Blob([stored[streamKey]], { type: 'application/vnd.apple.mpegurl' });
                    loadAndPlayStream(URL.createObjectURL(blob));
                } else {
                    alert("Stream not found in localStorage.");
                }
            }

            const subtitleInterval = setInterval(() => {
                if (disableSubtitles()) {
                    setTimeout(disableSubtitles, 2000);
                    clearInterval(subtitleInterval);
                }
            }, 500);

            let selectedChannel = localStorage.getItem('selectedChannel');
            let isMatch = false;

            if (selectedChannel && channelLinkMap[selectedChannel] === urlCheck) {
                isMatch = true;
            }

            if (!isMatch && urlCheck) {
                for (const id in channelLinkMap) {
                    if (channelLinkMap[id] === urlCheck) {
                        selectedChannel = id;
                        localStorage.setItem('selectedChannel', id);
                        break;
                    }
                }
            }

            const currentIndex = channelsOrder.findIndex(c => c.id === selectedChannel);
            const prevId = localStorage.getItem('prevChannel');
            const prevIndex = channelsOrder.findIndex(c => c.id === prevId);

            const currentChannelObj = channelsOrder.find(c => c.id === selectedChannel);
            document.title = currentChannelObj ? currentChannelObj.name : "Live TV";

            localStorage.setItem("Matchey", String(isMatch));

            // REMOVED: The old video.addEventListener("contextmenu", ...) for subtitles
            // because the new handleContextMenu handles it at the document level.

            window.addEventListener("keydown", ev => {

                if (ev.key === "Enter") {
                    video.play();
                }

                else if (ev.key === "Escape" ||
                        (ev.key === "ArrowLeft" && ev.metaKey)) {
                    ev.preventDefault();
                    const back = channelsOrder[prevIndex];
                    if (!back) return;
                    localStorage.setItem('prevChannel', back.id);
                    location.href = channelLinkMap[back.id];
                }

                else if (ev.key === "ArrowLeft") {
                    let idx = currentIndex - 1;
                    if (idx < 0) idx = channelsOrder.length - 1;
                    const prev = channelsOrder[idx];
                    localStorage.setItem('selectedChannel', prev.id);
                    location.href = channelLinkMap[prev.id];
                }

                else if (ev.key === "ArrowRight") {
                    let idx = (currentIndex + 1) % channelsOrder.length;
                    const next = channelsOrder[idx];
                    localStorage.setItem('selectedChannel', next.id);
                    location.href = channelLinkMap[next.id];
                }

                else if (ev.key === "ArrowUp") {
                    const desc = document.getElementById('video-description');
                    desc.style.display = desc.style.display === 'block' ? 'none' : 'block';
                }

                else if (ev.key === "ArrowDown") {
                    video.muted = !video.muted;

                    // Auto enable subtitles if muted
                    const tracks = video.textTracks;
                    for (let t of tracks) {
                        if (t.kind === 'subtitles' || t.kind === 'captions') {
                            t.mode = video.muted ? 'showing' : 'hidden';
                        }
                    }
                }
            });

            const xmlUrl = "https://epg.dunc.app/epg.xml";

            if (selectedChannel) {
                fetch(xmlUrl)
                    .then(r => r.text())
                    .then(t => new DOMParser().parseFromString(t, "text/xml"))
                    .then(xml => {
                        const now = new Date();
                        now.setMinutes(now.getMinutes() + now.getTimezoneOffset()); 

                        const progs = xml.getElementsByTagName("programme");
                        for (const p of progs) {
                            if (p.getAttribute("channel") !== selectedChannel) continue;

                            const start = parseEpgDate(p.getAttribute("start"));
                            const stop  = parseEpgDate(p.getAttribute("stop"));

                            if (now >= start && now <= stop) {
                                const desc = p.getElementsByTagName("desc")[0];
                                const text = desc ? desc.textContent : "No description available";
                                document.getElementById("video-description").innerText = text;
                                localStorage.setItem("descripto", text);
                                break;
                            }
                        }
                    });
            }

            function parseEpgDate(str) {
                return new Date(
                    str.replace(" +0000", "")
                       .replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/,
                                "$1-$2-$3T$4:$5:$6")
                );
            }
        });
    </script>
</body>
</html>
