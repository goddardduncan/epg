<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="https://epg.dunc.app/favicon.ico" type="image/x-icon">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live TV</title>

    <style>
        html, body, #video-container {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            background-color: #000;
            /* Prevents mobile browser "swipe to go back" gestures from interfering */
            touch-action: none; 
        }

        #video {
            width: 100%;
            height: 100%;
        }

        #video-description {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            background-color: rgba(0,0,0,0.5);
            color: #fff;
            padding: 10px;
            text-align: center;
            font-size: 1.5em;
            font-family: 'Roboto', sans-serif;
            box-sizing: border-box;
            display: none;
            pointer-events: none; /* Let touches pass through to the container */
        }

        #channel-source-debug {
            position: absolute;
            top: 5px;
            right: 10px;
            background: rgba(0,0,0,0.4);
            padding: 4px 8px;
            color: #fff;
            font-size: 12px;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="video" autoplay controls playsinline></video>
        <div id="video-description"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <script>
        const channelSourceKey = 'channelSource';
        const channelSource = localStorage.getItem(channelSourceKey) || 'channels.json';

        const DOUBLE_CLICK_TIME_MS = 500;
        const STANDBY_URL = 'https://dj.dunc.app/control/standby';
        const ON_URL = 'https://dj.dunc.app/control/epg';
        const SWIPE_THRESHOLD = 70; // Minimum pixels to trigger a channel change

        let lastContextMenuTimestamp = 0;
        let contextMenuTimer = null;
        let touchStartX = 0;
        let touchEndX = 0;
        
        const video = document.getElementById('video');
        const videoContainer = document.getElementById('video-container');

        // --- Shared Channel Change Logic ---
        function changeChannel(direction, channelsOrder, currentIndex, channelLinkMap) {
            let idx;
            if (direction === 'prev') {
                idx = currentIndex - 1;
                if (idx < 0) idx = channelsOrder.length - 1;
            } else {
                idx = (currentIndex + 1) % channelsOrder.length;
            }
            
            const target = channelsOrder[idx];
            if (target && channelLinkMap[target.id]) {
                localStorage.setItem('selectedChannel', target.id);
                location.href = channelLinkMap[target.id];
            }
        }

        // --- Subtitle Toggle ---
        function toggleSubtitles() {
            const tracks = video.textTracks;
            for (let t of tracks) {
                if (t.kind === 'subtitles' || t.kind === 'captions') {
                    t.mode = t.mode === 'showing' ? 'hidden' : 'showing';
                }
            }
        }

        // --- Request Sender ---
        async function sendRequest(url, commandName) {
            try {
                const response = await fetch(url, { method: 'POST' });
                if (response.ok) console.log(`${commandName} command sent.`);
            } catch (error) {
                console.error(`Error sending ${commandName}:`, error);
            }
        }

        // --- Context Menu (Subtitles/Standby/On) ---
        async function handleContextMenu(event) {
            event.preventDefault();
            const currentTime = Date.now();
            const timeSinceLastClick = currentTime - lastContextMenuTimestamp;

            if (timeSinceLastClick < DOUBLE_CLICK_TIME_MS) {
                clearTimeout(contextMenuTimer);
                contextMenuTimer = null;
                lastContextMenuTimestamp = 0;
                await sendRequest(STANDBY_URL, 'Standby');
            } else {
                toggleSubtitles(); 
                if (contextMenuTimer) clearTimeout(contextMenuTimer);
                contextMenuTimer = setTimeout(async () => {
                    await sendRequest(ON_URL, 'On');
                    contextMenuTimer = null;
                    lastContextMenuTimestamp = 0;
                }, DOUBLE_CLICK_TIME_MS);
                lastContextMenuTimestamp = currentTime;
            }
        }

        document.addEventListener("contextmenu", handleContextMenu);

        // --- Core Data Loaders ---
        async function loadChannelOrder() {
            try {
                const response = await fetch('channelorder.json');
                return await response.json();
            } catch (e) {
                return [];
            }
        }

        async function loadChannelLinkMap() {
            try {
                const response = await fetch(channelSource);
                return await response.json();
            } catch (e) {
                return {};
            }
        }

        function getUrlParameter(name) {
            const regex = new RegExp('[?&]' + name + '=([^&#]*)');
            const result = regex.exec(location.search);
            return result ? decodeURIComponent(result[1]) : '';
        }

        function getUrlParameterCheck(name, url) {
            const base = 'https://goddardduncan.github.io/epg/';
            return url.includes(base) ? url.slice(url.indexOf(base) + base.length) : url;
        }

        async function loadAndPlayStream(url) {
            if (Hls.isSupported()) {
                const hls = new Hls();
                hls.loadSource(url);
                hls.attachMedia(video);
                hls.on(Hls.Events.MANIFEST_PARSED, () => video.play());
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = url;
                video.play();
            }
        }

        function disableSubtitles() {
            const tracks = video.textTracks;
            let found = false;
            for (let t of tracks) {
                if (t.kind === 'subtitles' || t.kind === 'captions') {
                    t.mode = 'hidden';
                    found = true;
                }
            }
            return found;
        }

        // --- Initialization ---
        document.addEventListener("DOMContentLoaded", async () => {
            const channelsOrder = await loadChannelOrder();
            const channelLinkMap = await loadChannelLinkMap();

            const urlParameter = getUrlParameter('url');
            const streamKey = getUrlParameter('stream');
            const urlCheck = getUrlParameterCheck('url', location.href);

            if (urlParameter) {
                loadAndPlayStream(urlParameter);
            } else if (streamKey) {
                const stored = JSON.parse(localStorage.getItem('m3u8Files') || '{}');
                if (stored[streamKey]) {
                    const blob = new Blob([stored[streamKey]], { type: 'application/vnd.apple.mpegurl' });
                    loadAndPlayStream(URL.createObjectURL(blob));
                }
            }

            const subtitleInterval = setInterval(() => {
                if (disableSubtitles()) {
                    setTimeout(disableSubtitles, 2000);
                    clearInterval(subtitleInterval);
                }
            }, 500);

            let selectedChannel = localStorage.getItem('selectedChannel');
            
            // Sync current channel ID based on URL
            for (const id in channelLinkMap) {
                if (channelLinkMap[id] === urlCheck) {
                    selectedChannel = id;
                    localStorage.setItem('selectedChannel', id);
                    break;
                }
            }

            const currentIndex = channelsOrder.findIndex(c => c.id === selectedChannel);
            const prevId = localStorage.getItem('prevChannel');
            const prevIndex = channelsOrder.findIndex(c => c.id === prevId);

            const currentChannelObj = channelsOrder.find(c => c.id === selectedChannel);
            document.title = currentChannelObj ? currentChannelObj.name : "Live TV";

            // --- TOUCH GESTURE LISTENERS ---
            videoContainer.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });

            videoContainer.addEventListener('touchend', e => {
                touchEndX = e.changedTouches[0].screenX;
                const swipeDistance = touchEndX - touchStartX;

                if (Math.abs(swipeDistance) > SWIPE_THRESHOLD) {
                    if (swipeDistance > 0) {
                        // Swiped Right -> Previous
                        changeChannel('prev', channelsOrder, currentIndex, channelLinkMap);
                    } else {
                        // Swiped Left -> Next
                        changeChannel('next', channelsOrder, currentIndex, channelLinkMap);
                    }
                }
            }, { passive: true });

            // --- KEYBOARD LISTENERS ---
            window.addEventListener("keydown", ev => {
                if (ev.key === "Enter") {
                    video.play();
                }
                else if (ev.key === "Escape" || (ev.key === "ArrowLeft" && ev.metaKey)) {
                    ev.preventDefault();
                    const back = channelsOrder[prevIndex];
                    if (back) location.href = channelLinkMap[back.id];
                }
                else if (ev.key === "ArrowLeft") {
                    changeChannel('prev', channelsOrder, currentIndex, channelLinkMap);
                }
                else if (ev.key === "ArrowRight") {
                    changeChannel('next', channelsOrder, currentIndex, channelLinkMap);
                }
                else if (ev.key === "ArrowUp") {
                    const desc = document.getElementById('video-description');
                    desc.style.display = desc.style.display === 'block' ? 'none' : 'block';
                }
                else if (ev.key === "ArrowDown") {
                    video.muted = !video.muted;
                    const tracks = video.textTracks;
                    for (let t of tracks) {
                        if (t.kind === 'subtitles' || t.kind === 'captions') {
                            t.mode = video.muted ? 'showing' : 'hidden';
                        }
                    }
                }
            });

            // --- EPG LOADING ---
            if (selectedChannel) {
                fetch("https://epg.dunc.app/epg.xml")
                    .then(r => r.text())
                    .then(t => new DOMParser().parseFromString(t, "text/xml"))
                    .then(xml => {
                        const now = new Date();
                        now.setMinutes(now.getMinutes() + now.getTimezoneOffset()); 
                        const progs = xml.getElementsByTagName("programme");
                        for (const p of progs) {
                            if (p.getAttribute("channel") !== selectedChannel) continue;
                            const start = parseEpgDate(p.getAttribute("start"));
                            const stop  = parseEpgDate(p.getAttribute("stop"));
                            if (now >= start && now <= stop) {
                                const desc = p.getElementsByTagName("desc")[0];
                                const text = desc ? desc.textContent : "No description available";
                                document.getElementById("video-description").innerText = text;
                                break;
                            }
                        }
                    });
            }

            function parseEpgDate(str) {
                return new Date(str.replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
            }
        });
    </script>
</body>
</html>
