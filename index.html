<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="https://epg.dunc.app/favicon.ico" type="image/x-icon">
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="300">
    <title>Melbourne Live TV Guide</title>
    <style>
        body {
            background-color: #1e2d3b;
            color: #d4d4d4;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        h1 {
            text-align: center;
            font-size: 36px;
            margin: 20px 0;
            color: #4f5e80;
            cursor: default;
            user-select: none;
        }
        table {
            border-collapse: collapse;
            margin: 20px auto;
            width: 95%;
            max-width: 1200px;
            background-color: #263544;
            border-radius: 8px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #33475b;
            position: relative;
        }
        th {
            background-color: #33475b;
            color: #ffffff;
            font-size: 18px;
            font-weight: 500;
            position: sticky;
            top: 0;
            z-index: 2;
        }
        img {
            width: 100px;
            height: 60px;
            border-radius: 8px;
        }
        tr:not(:first-child).selected {
            background-color: #13508a;
            color: #FFFFFF;
        }
        .progress-bar {
            position: absolute;
            width: 23px;
            height: 10%;
            background-color: rgba(255, 255, 255, 0.5);
            bottom: 3px;
            left: 0;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        .progress-bar:hover {
            background-color: rgba(255, 255, 255, 0.8);
        }
        .knob {
            position: absolute;
            bottom: 14px;
            left: 0;
            padding: 5px 10px;
            background-color: #4f5e80;
            color: white;
            border-radius: 12px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transform: translateX(-50%);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        .progress-bar:hover .knob {
            opacity: 1;
            transform: translateX(-50%) scale(1.1);
        }
        .icon {
            cursor: pointer;
        }
        #video-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 200px;
            border-radius: 10px;
            border: 2px solid grey;
            display: none;
            z-index: 9999;
        }
        iframe {
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            border: none;
        }

        /* Settings modal */
        #settings-modal {
            display: none;
            position: fixed;
            z-index: 10000; /* above video overlay */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
        }
        #settings-modal .modal-content {
            background-color: #263544;
            margin: 10% auto;
            padding: 20px 24px 24px;
            border: 1px solid #4f5e80;
            border-radius: 10px;
            max-width: 420px;
            color: #d4d4d4;
            position: relative;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }
        #settings-modal h2 {
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 22px;
            color: #ffffff;
        }
        .modal-close {
            position: absolute;
            top: 10px;
            right: 14px;
            font-size: 22px;
            cursor: pointer;
            color: #d4d4d4;
        }
        .settings-group {
            margin-bottom: 18px;
        }
        .settings-group-title {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #9ca9c5;
            margin-bottom: 8px;
        }
        .settings-options {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .settings-options label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        .settings-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 16px;
        }
        .settings-footer button {
            padding: 6px 14px;
            border-radius: 6px;
            border: none;
            font-size: 14px;
            cursor: pointer;
        }
        #settingsCancel {
            background-color: transparent;
            color: #d4d4d4;
            border: 1px solid #4f5e80;
        }
        #settingsSave {
            background-color: #13508a;
            color: #ffffff;
        }

        /* Toggle switch for standby */
        .switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background-color: #4f5e80;
            transition: .2s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .2s;
            border-radius: 50%;
        }
        .switch input:checked + .slider {
            background-color: #13508a;
        }
        .switch input:checked + .slider:before {
            transform: translateX(22px);
        }
    </style>
</head>
<body>
    <h1>Melbourne Live TV Guide</h1>

    <!-- Settings modal -->
    <div id="settings-modal">
        <div class="modal-content">
            <span id="settingsClose" class="modal-close">&times;</span>
            <h2>Settings</h2>

            <div class="settings-group">
                <div class="settings-group-title">Channel Links Source</div>
                <div class="settings-options">
                    <label>
                        <input type="radio" name="channelSource" value="channels.json">
                        <span>channels.json</span>
                    </label>
                    <label>
                        <input type="radio" name="channelSource" value="rpichannels.json">
                        <span>rpichannels.json</span>
                    </label>
                    <label>
                        <input type="radio" name="channelSource" value="androidchannels.json">
                        <span>androidchannels.json</span>
                    </label>
                    <label>
                        <input type="radio" name="channelSource" value="joshchannels.json">
                        <span>joshchannels.json</span>
                    </label>
                </div>
            </div>

        <div class="settings-group">
            <div class="settings-group-title">Standby on Right-Click</div>
            <div class="settings-options">
                <span>Enable standby request</span>
                <label class="switch">
                    <input type="checkbox" id="standbyToggle">
                    <span class="slider"></span>
                </label>
            </div>    
        </div>

        <div class="settings-group">
            <div class="settings-group-title">Extra Channels</div>
            <div class="settings-options">
                <span>Show "The Block" Row</span>
                <label class="switch">
                    <input type="checkbox" id="showBlockToggle">
                    <span class="slider"></span>
                </label>
            </div><br>
            <div class="settings-options">
                <span>Show "TreenFlix" Row</span>
                <label class="switch">
                    <input type="checkbox" id="showTreenflixToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

            <div class="settings-footer">
                <button id="settingsCancel" type="button">Cancel</button>
                <button id="settingsSave" type="button">Save</button>
            </div>
        </div>
    </div>

    <table>
        <tr>
            <th>Channel</th>
            <th></th>
            <th>What's Playing</th>
            <th>Start Time</th>
            <th>End Time</th>
            <th>What's Up Next</th>
            <th>Start Time</th>
            <th>End Time</th>
        </tr>

        <script>
            // --- Global settings for channel source and standby behavior ---
            const channelSourceKey = 'channelSource';
            const standbyEnabledKey = 'standbyEnabled';
            const blockEnabledKey = 'showBlockRow';
            const treenflixEnabledKey = 'showTreenflixRow';
            const FALLBACK_IMAGE = "https://i.redd.it/6w3zd8ozw2k21.jpg";

            let channelSource = localStorage.getItem(channelSourceKey) || 'channels.json';

            const standbyStored = localStorage.getItem(standbyEnabledKey);
            let standbyEnabled = standbyStored === null ? true : (standbyStored === 'true');
            let showBlockRow = localStorage.getItem(blockEnabledKey) === 'true';
            let showTreenflixRow = localStorage.getItem(treenflixEnabledKey) === 'true';
            

            let blockUrl; // Global variable for blockUrl

            // --- Settings modal helpers ---

            function openSettingsModal() {
                const modal = document.getElementById('settings-modal');
                document.getElementById('showBlockToggle').checked = showBlockRow;
                document.getElementById('showTreenflixToggle').checked = showTreenflixRow;
                modal.style.display = 'block';
                if (!modal) return;

                // Set current channel source radio
                const radios = document.querySelectorAll('input[name="channelSource"]');
                radios.forEach(radio => {
                    radio.checked = (radio.value === channelSource);
                });

                // Set standby toggle
                const standbyToggle = document.getElementById('standbyToggle');
                if (standbyToggle) {
                    standbyToggle.checked = !!standbyEnabled;
                }

                modal.style.display = 'block';
            }

            function closeSettingsModal() {
                const modal = document.getElementById('settings-modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            }

            (function setupSettingsModal() {
                const modal = document.getElementById('settings-modal');
                const closeBtn = document.getElementById('settingsClose');
                const saveBtn = document.getElementById('settingsSave');
                const cancelBtn = document.getElementById('settingsCancel');

                if (closeBtn) {
                    closeBtn.addEventListener('click', closeSettingsModal);
                }
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', closeSettingsModal);
                }
                if (saveBtn) {
                    saveBtn.addEventListener('click', function() {
                        const selectedRadio = document.querySelector('input[name="channelSource"]:checked');
                        const newChannelSource = selectedRadio ? selectedRadio.value : 'channels.json';

                        const standbyToggle = document.getElementById('standbyToggle');
                        const newStandbyEnabled = standbyToggle ? standbyToggle.checked : true;
                        const newShowBlock = document.getElementById('showBlockToggle').checked;
                        const newShowTreenflix = document.getElementById('showTreenflixToggle').checked;

                        localStorage.setItem(channelSourceKey, newChannelSource);
                        localStorage.setItem(standbyEnabledKey, newStandbyEnabled ? 'true' : 'false');
                        localStorage.setItem(blockEnabledKey, newShowBlock);
                        localStorage.setItem(treenflixEnabledKey, newShowTreenflix);

                        channelSource = newChannelSource;
                        standbyEnabled = newStandbyEnabled;

                        closeSettingsModal();
                        // Reload the page so that new channel source is used everywhere
                        location.reload();
                    });
                }

                // Close when clicking on backdrop
                if (modal) {
                    window.addEventListener('click', function(event) {
                        if (event.target === modal) {
                            closeSettingsModal();
                        }
                    });
                }

                // Triple-click on title to open settings
                const title = document.querySelector('h1');
                if (title) {
                    let clickCount = 0;
                    let clickTimer = null;

                    title.addEventListener('click', function() {
                        clickCount++;
                        if (clickCount === 3) {
                            clickCount = 0;
                            if (clickTimer) {
                                clearTimeout(clickTimer);
                                clickTimer = null;
                            }
                            openSettingsModal();
                        } else {
                            if (clickTimer) {
                                clearTimeout(clickTimer);
                            }
                            clickTimer = setTimeout(function() {
                                clickCount = 0;
                                clickTimer = null;
                            }, 600);
                        }
                    });
                }
            })();

            // Function to refresh Gist
            async function refreshGist() {
                try {
                    const response = await fetch('https://api.github.com/gists/20ba022255783133d8b9808ba1371b42');
                    const gist = await response.json();
                    const file = gist.files['refresh.now'];
                    const newContent = (parseInt(file.content) + 1).toString();
                    const tok1 = 'T16nNuEDxoPN3r3p';
                    const tok2 = 'FTn9gbcgBn3aVT4P0Gyv';
                    const token = `ghp_${tok1}${tok2}`;
                    
                    await fetch('https://api.github.com/gists/20ba022255783133d8b9808ba1371b42', {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `token ${token}`
                        },
                        body: JSON.stringify({
                            files: {
                                'refresh.now': {
                                    content: "1"
                                }
                            }
                        })
                    });

                    console.log('Gist updated successfully with new content:', newContent);
                } catch (error) {
                    console.error('Error updating gist:', error);
                }
            }

            async function loadChannelMap() {
                try {
                    const response = await fetch('channelorder.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const channelOrder = await response.json();
                    const channelMap = channelOrder.reduce((map, channel) => {
                        map[channel.id] = channel.name;
                        return map;
                    }, {});
                    return channelMap;
                } catch (error) {
                    console.error('Failed to load channel order:', error);
                    return {};
                }
            }

            async function loadChannelLinkMap() {
                try {
                    const response = await fetch(channelSource);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const channelLinkMap = await response.json();
                    return channelLinkMap;
                } catch (error) {
                    console.error('Failed to load channel links:', error);
                    return {};
                }
            }

            async function fetchStreams() {
                try {
                    const response = await fetch('https://epg.dunc.app/9now.json');
                    if (!response.ok) {
                        throw new Error(`Failed to fetch stream URLs: ${response.statusText}`);
                    }
                    const allStreams = await response.json();
                    return {
                        "mjh-channel-9-vic": allStreams["mjh-channel-9-vic"],
                        "mjh-gem-vic": allStreams["mjh-gem-vic"],
                        "mjh-go-vic": allStreams["mjh-go-vic"],
                        "mjh-life-vic": allStreams["mjh-life-vic"],
                        "mjh-rush-vic": allStreams["mjh-rush-vic"]
                    };
                } catch (error) {
                    console.error('Error fetching streams:', error);
                    return {};
                }
            }

            function fetchAndStoreFile(url, streamKey) {
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to fetch m3u8 file from ${url}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(m3u8Content => {
                        let storedContent = JSON.parse(localStorage.getItem('m3u8Files')) || {};
                        storedContent[streamKey] = m3u8Content;
                        localStorage.setItem('m3u8Files', JSON.stringify(storedContent));
                        console.log('Saved m3u8 file for ' + streamKey);
                    })
                    .catch(error => {
                        console.error(error);
                    });
            }

            async function startSavingToLocalStorage() {
                try {
                    const streams = await fetchStreams();
                    let delay = 0;
                    for (let streamKey in streams) {
                        let streamUrl = streams[streamKey];
                        setTimeout(() => {
                            fetchAndStoreFile(streamUrl, streamKey);
                        }, delay);
                        delay += 1000;
                    }
                    setTimeout(startSavingToLocalStorage, 100000);
                } catch (error) {
                    console.error('Error during saving to local storage:', error);
                }
            }

            function createProgressBar(adjustedStart, adjustedEnd, cell) {
                try {
                    const timezoneOffsetInMinutes = new Date().getTimezoneOffset();
                    const currentTimeUTC = new Date(new Date().getTime() + timezoneOffsetInMinutes * 60 * 1000);

                    if (currentTimeUTC >= adjustedStart && currentTimeUTC <= adjustedEnd) {
                        const duration = adjustedEnd - adjustedStart;
                        const remainingTime = Math.floor((adjustedEnd - currentTimeUTC) / (1000 * 60)); // Remaining time in minutes
                        const progressPercentage = ((currentTimeUTC - adjustedStart) / duration) * 100;
                        const progressBar = document.createElement('div');
                        progressBar.className = 'progress-bar';
                        progressBar.style.left = progressPercentage + '%';
                        cell.style.position = 'relative';

                        const knob = document.createElement('div');
                        knob.className = 'knob';
                        knob.innerText = `${remainingTime} minutes remain`;
                        progressBar.appendChild(knob);
                        cell.appendChild(progressBar);
                    } else {
                        console.log('Current time is outside the program time range');
                    }
                } catch (error) {
                    console.error('Error creating progress bar:', error);
                }
            }

            async function loadTreenFlix() {
                try {
                    const playUrl = `https://treen.dunc.app/`;
            //        const playUrl = `http://10.1.1.44:8090/`;
                    const TfTitle = "TreenFlix";
                    const TfImage = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTsufhswc5ch8SCEP0gtGVPG1Z_K-4qF7semg&s";

                    const TfRow = document.createElement("tr");

                    const channelCell = document.createElement("td");
                    channelCell.appendChild(document.createTextNode("TreenFlix"));
                    TfRow.appendChild(channelCell);

                    const iconCell = document.createElement("td");
                    const iconImg = document.createElement("img");
                    iconImg.setAttribute('class', 'icon');
                    iconImg.src = TfImage;
                    iconImg.dataset.channelLink = playUrl;
                    iconImg.dataset.channelId = "treenflix";
                    iconImg.addEventListener("click", function() {
                        window.location.href = playUrl;
                    });
                    iconCell.appendChild(iconImg);
                    TfRow.appendChild(iconCell);

                    const titleCell = document.createElement("td");
                    titleCell.colSpan = 5;
                    titleCell.style.textAlign = 'center';
                    titleCell.style.cursor = 'pointer';
                    titleCell.appendChild(document.createTextNode(TfTitle));
                    titleCell.addEventListener("click", function() {
                        window.location.href = playUrl;
                    });
                    TfRow.appendChild(titleCell);

                    const table = document.querySelector('table');
                    table.appendChild(TfRow);
                } catch (error) {
                    console.error('Error loading TreenFlix:', error);
                }
            }

            async function loadTreenFlixReset() {
                try {
                    const playUrl = `https://pi.dunc.app`;
                    const TfTitle = "Reset TreenFlix";
                    const TfImage = "https://i.redd.it/6w3zd8ozw2k21.jpg";

                    const TfRow = document.createElement("tr");

                    const channelCell = document.createElement("td");
                    channelCell.appendChild(document.createTextNode("Reset TreenFlix"));
                    TfRow.appendChild(channelCell);

                    const iconCell = document.createElement("td");
                    const iconImg = document.createElement("img");
                    iconImg.setAttribute('class', 'icon');
                    iconImg.src = TfImage;
                    iconImg.dataset.channelLink = playUrl;
                    iconImg.dataset.channelId = "treenflixreset";
                    iconImg.addEventListener("click", function() {
                        window.location.href = playUrl;
                    });
                    iconCell.appendChild(iconImg);
                    TfRow.appendChild(iconCell);

                    const titleCell = document.createElement("td");
                    titleCell.colSpan = 5;
                    titleCell.style.textAlign = 'center';
                    titleCell.style.cursor = 'pointer';
                    titleCell.appendChild(document.createTextNode(TfTitle));
                    titleCell.addEventListener("click", function() {
                        window.location.href = playUrl;
                    });
                    TfRow.appendChild(titleCell);

                    const table = document.querySelector('table');
                    table.appendChild(TfRow);
                } catch (error) {
                    console.error('Error loading TreenFlixReset:', error);
                }
            }

            async function loadBlockEpisode() {
                try {
                    const timestamp = new Date().getTime();
                    const response = await fetch(`https://gist.githubusercontent.com/goddardduncan/ef1603dc35dcd55840a58ecf8b94bf8b/raw/block.json?t=${timestamp}`);
                    if (!response.ok) {
                        throw new Error(`Failed to load block episode: ${response.statusText}`);
                    }
                    const blockData = await response.json();
                    blockUrl = blockData.block; // Assigning global blockUrl
                    const playUrl = `Playm3u8.html?url=https://b.goddardduncan.workers.dev/block.m3u8`;
                    const blockTitle = "Latest Block Episode";
                    const blockImage = "https://www.fetchtv.com.au/v2/epg/program/153946/image";

                    const blockRow = document.createElement("tr");

                    const channelCell = document.createElement("td");
                    channelCell.appendChild(document.createTextNode("The Block"));
                    blockRow.appendChild(channelCell);

                    const iconCell = document.createElement("td");
                    const iconImg = document.createElement("img");
                    iconImg.setAttribute('class', 'icon');
                    iconImg.src = blockImage;
                    iconImg.addEventListener("click", function() {
                        window.location.href = playUrl;
                    });
                    iconCell.appendChild(iconImg);
                    blockRow.appendChild(iconCell);

                    const titleCell = document.createElement("td");
                    titleCell.colSpan = 5;
                    titleCell.style.textAlign = 'center';
                    titleCell.style.cursor = 'pointer';
                    titleCell.appendChild(document.createTextNode(blockTitle));
                    titleCell.addEventListener("click", function() {
                        window.location.href = playUrl;
                    });
                    blockRow.appendChild(titleCell);

                    const table = document.querySelector('table');
                    table.appendChild(blockRow);
                } catch (error) {
                    console.error('Error loading the latest Block episode:', error);
                }
            }

            async function initTVGuide() {
                const channelMap = await loadChannelMap();
                const channelLinkMap = await loadChannelLinkMap();
                startSavingToLocalStorage();
                let selectedRowIndex = -1;
                let videoOverlayVisible = false;

                document.addEventListener("keydown", function(event) {
                    if (["ArrowUp", "ArrowDown", "ArrowRight", "Enter"].includes(event.key)) {
                        event.preventDefault();
                        const tableRows = document.querySelectorAll('table tr');
                        if (event.key === "ArrowUp") {
                            if (selectedRowIndex > 0) {
                                tableRows[selectedRowIndex].classList.remove("selected");
                                selectedRowIndex--;
                                tableRows[selectedRowIndex].classList.add("selected");
                                scrollSelectedRowIntoView();
                            }
                        } else if (event.key === "ArrowDown") {
                            if (selectedRowIndex < tableRows.length - 1) {
                                if (selectedRowIndex !== -1) {
                                    tableRows[selectedRowIndex].classList.remove("selected");
                                }
                                selectedRowIndex++;
                                tableRows[selectedRowIndex].classList.add("selected");
                                scrollSelectedRowIntoView();
                            }
                        } else if (event.key === "Enter") {
                            if (selectedRowIndex === 0) {
                                refreshGist();
                            } else if (selectedRowIndex !== -1) {
                                const selectedRow = tableRows[selectedRowIndex];
                                if (selectedRow.innerText.includes("The Block")) {
                                    const iconImg = selectedRow.querySelector('img');
                                    iconImg.click();
                                } else {
                                    const image = selectedRow.querySelector('img');
                                    const channelLink = image.dataset.channelLink;
                                    window.location.href = channelLink;
                                    const channelId = image.dataset.channelId;
                                    localStorage.setItem('selectedChannel', channelId);
                                    localStorage.setItem('prevChannel', channelId);
                                }
                            }
                        } else if (event.key === "ArrowRight") {
                            const selectedRow = tableRows[selectedRowIndex];
                            const image = selectedRow.querySelector('img');
                            const channelLink = image.dataset.channelLink;

                            if (selectedRow.innerText.includes("The Block")) {
                                const playUrl = `Playm3u8.html?url=${encodeURIComponent(blockUrl)}`;
                                if (!videoOverlayVisible) {
                                    showVideoOverlay(playUrl, image);
                                } else {
                                    hideVideoOverlay();
                                }
                            } else {
                                if (!videoOverlayVisible) {
                                    showVideoOverlay(channelLink, image);
                                } else {
                                    hideVideoOverlay();
                                }
                            }
                        }
                    }
                });
const DOUBLE_CLICK_TIME_MS = 500;
const STANDBY_URL = 'https://dj.dunc.app/control/standby';
const ON_URL = 'https://dj.dunc.app/control/epg';
let lastContextMenuTimestamp = 0;
let contextMenuTimer = null;


let standbyStored = localStorage.getItem('standbyEnabled');
let standbyEnabled = standbyStored === null ? true : (standbyStored === 'true');


document.addEventListener("contextmenu", async function(event) {
if (!standbyEnabled) return;
event.preventDefault();


const now = Date.now();
const delta = now - lastContextMenuTimestamp;


if (delta < DOUBLE_CLICK_TIME_MS) {
clearTimeout(contextMenuTimer);
contextMenuTimer = null;
lastContextMenuTimestamp = 0;
console.log('[STANDBY] Double right-click detected.');
await sendRequest(STANDBY_URL, 'Standby');
} else {
if (contextMenuTimer) clearTimeout(contextMenuTimer);
contextMenuTimer = setTimeout(async () => {
console.log('[ON] Single right-click detected.');
await sendRequest(ON_URL, 'On');
contextMenuTimer = null;
lastContextMenuTimestamp = 0;
}, DOUBLE_CLICK_TIME_MS);
lastContextMenuTimestamp = now;
}
});


async function sendRequest(url, label) {
try {
const res = await fetch(url, { method: 'POST' });
if (res.ok) {
console.log(`${label} request sent successfully.`);
} else {
console.error(`${label} request failed with status: ${res.status}`);
}
} catch (err) {
console.error(`Error sending ${label} request:`, err);
}
}
                
                function scrollSelectedRowIntoView() {
                    const tableRows = document.querySelectorAll('table tr');
                    const selectedRow = tableRows[selectedRowIndex];
                    const stickyRowHeight = document.querySelector('th').offsetHeight;
                    const selectedRowTop = selectedRow.getBoundingClientRect().top;
                    const offset = selectedRowTop - stickyRowHeight;

                    window.scrollBy({
                        top: offset,
                        behavior: 'smooth'
                    });
                }

                function showVideoOverlay(channelLink, imgElement) {
                    const videoOverlay = document.getElementById('video-overlay');
                    const videoPreview = document.getElementById('video-preview');

                    videoOverlay.style.display = 'block';
                    videoPreview.src = channelLink;
                    videoOverlayVisible = true;
                }

                function hideVideoOverlay() {
                    const videoOverlay = document.getElementById('video-overlay');
                    const videoPreview = document.getElementById('video-preview');

                    videoOverlay.style.display = 'none';
                    videoPreview.src = '';
                    videoOverlayVisible = false;
                }

                const table = document.querySelector('table');
                const xmlData = "https://epg.dunc.app/epg.xml";
                const timezoneOffsetInMinutes = new Date().getTimezoneOffset();

                fetch(xmlData)
                    .then(response => response.text())
                    .then(str => new window.DOMParser().parseFromString(str, "text/xml"))
                    .then(data => {
                        const programs = data.getElementsByTagName("programme");
                        const currentTime = new Date();
                        currentTime.setTime(currentTime.getTime() + (timezoneOffsetInMinutes * 60 * 1000));
                        const options = { hour12: true, hour: "numeric", minute: "numeric" };

                        const sortedChannels = Object.keys(channelMap).sort((a, b) => {
                            return Object.keys(channelMap).indexOf(a) - Object.keys(channelMap).indexOf(b);
                        });

                        sortedChannels.forEach(channelID => {
                            const channelPrograms = Array.from(programs).filter(program => program.getAttribute("channel") === channelID);

                            channelPrograms.forEach((program, index) => {
                                const channel = channelID;
                                const title = program.getElementsByTagName("title")[0].childNodes[0].nodeValue;
                                const start = new Date(program.getAttribute("start").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                const end = new Date(program.getAttribute("stop").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                const icon = program.getElementsByTagName("icon")[0].getAttribute("src");

                                const mappedChannel = channelMap[channel] || channel;
                                const mappedChannelLink = channelLinkMap[channel] || channel;

                                if (currentTime >= start && currentTime <= end) {
                                    const row = document.createElement("tr");

                                    const channelCell = document.createElement("td");
                                    channelCell.appendChild(document.createTextNode(mappedChannel));
                                    row.appendChild(channelCell);

                                    const iconCell = document.createElement("td");
                                    const iconImg = document.createElement("img");
                                    iconImg.setAttribute('class', 'icon');
                                    iconImg.src = icon;
                                    iconImg.onerror = function() {
                                        this.src = "https://i.redd.it/6w3zd8ozw2k21.jpg";
                                        this.onerror = null; 
                                    };
                                    iconImg.addEventListener("click", function() {
                                        window.location.href = mappedChannelLink;
                                        localStorage.setItem('prevChannel', channelID);
                                        localStorage.setItem('selectedChannel', channelID);
                                    });
                                    iconImg.dataset.channelLink = mappedChannelLink;
                                    iconImg.dataset.channelId = channel;
                                    iconCell.appendChild(iconImg);
                                    row.appendChild(iconCell);

                                    const titleCell = document.createElement("td");
                                    titleCell.appendChild(document.createTextNode(title));

                                    setTimeout(() => {
                                        createProgressBar(start, end, titleCell);
                                    }, 0);
                                    row.appendChild(titleCell);

                                    const startCell = document.createElement("td");
                                    const adjustedStart = new Date(start.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                    startCell.appendChild(document.createTextNode(adjustedStart.toLocaleTimeString("en-AU", options)));
                                    row.appendChild(startCell);

                                    const endCell = document.createElement("td");
                                    const adjustedEnd = new Date(end.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                    endCell.appendChild(document.createTextNode(adjustedEnd.toLocaleTimeString("en-AU", options)));
                                    row.appendChild(endCell);

                                    const nextProgram = channelPrograms[index + 1];
                                    if (nextProgram) {
                                        const Ntitle = nextProgram.getElementsByTagName("title")[0].childNodes[0].nodeValue;
                                        const Nstart = new Date(nextProgram.getAttribute("start").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                        const Nend = new Date(nextProgram.getAttribute("stop").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));

                                        const NtitleCell = document.createElement("td");
                                        NtitleCell.appendChild(document.createTextNode(Ntitle));
                                        row.appendChild(NtitleCell);

                                        const nextStartCell = document.createElement("td");
                                        const adjustedNextStart = new Date(Nstart.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                        nextStartCell.appendChild(document.createTextNode(adjustedNextStart.toLocaleTimeString("en-AU", options)));
                                        row.appendChild(nextStartCell);

                                        const nextEndCell = document.createElement("td");
                                        const adjustedNextEnd = new Date(Nend.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                        nextEndCell.appendChild(document.createTextNode(adjustedNextEnd.toLocaleTimeString("en-AU", options)));
                                        row.appendChild(nextEndCell);
                                    }

                                    table.appendChild(row);
                                }
                            });
                        });

                        table.querySelector('tr').classList.add("selected");
                        selectedRowIndex = 0;
                        scrollSelectedRowIntoView();

                        const storedChannel = localStorage.getItem('selectedChannel');
                        if (storedChannel) {
                            const storedChannelRow = table.querySelector(`img[data-channel-id="${storedChannel}"]`).parentNode.parentNode;
                            const rows = table.querySelectorAll('tr');
                            rows.forEach((row, index) => {
                                if (row === storedChannelRow) {
                                    row.classList.add("selected");
                                    selectedRowIndex = index;
                                }
                            });
                            scrollSelectedRowIntoView();
                        }
                    });

                let wakeLock = null;

                const requestWakeLock = async () => {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Screen wake lock is active');
                    } catch (err) {
                        console.error(`${err.name}, ${err.message}`);
                    }
                };

                const handleVisibilityChange = () => {
                    if (wakeLock !== null && document.visibilityState === 'visible') {
                        requestWakeLock();
                    }
                };

                document.addEventListener('visibilitychange', handleVisibilityChange);
                requestWakeLock();

                // Load the latest Block episode after loading the guide
                setTimeout(async () => {
                    if (showBlockRow) {
                        await loadBlockEpisode();
                    }
                    if (showTreenflixRow) {
                        await loadTreenFlix();
                    }
                //    await loadTreenFlixReset();
                }, 50); // Adding a delay
            }

            initTVGuide();
        </script>
    </table>

    <div id="video-overlay">
        <iframe id="video-preview" allow="autoplay; fullscreen"></iframe>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function(event) {
            function displayButtonsOnMobile() {
                var screenWidth = window.innerWidth;
                var mobileButtonsDiv = document.getElementById("mobileButtons");
                
                if (screenWidth <= 1024) {
                    mobileButtonsDiv.style.display = "none";
                } else {
                    mobileButtonsDiv.style.display = "none";
                }
            }

            displayButtonsOnMobile();
            window.onresize = displayButtonsOnMobile;
        });
    </script>

    <div id="mobileButtons" style="text-align: center; margin-top: 20px; display: none;">
        <button onclick="window.location.href = 'https://goddardduncan.github.io/tvcast/';">ChromeCast</button>
    </div>
</body>
</html>
