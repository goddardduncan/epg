<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="https://goddardduncan.github.io/epg/favicon.ico" type="image/x-icon">
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="300">
    <title>Melbourne Live TV Guide</title>
    <style>
        body {
            background-color: #1e2d3b;
            color: #d4d4d4;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        h1 {
            text-align: center;
            font-size: 36px;
            margin: 20px 0;
            color: #4f5e80;
        }
        table {
            border-collapse: collapse;
            margin: 20px auto;
            width: 95%;
            max-width: 1200px;
            background-color: #263544;
            border-radius: 8px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #33475b;
        }
        th {
            background-color: #33475b;
            color: #ffffff;
            font-size: 18px;
            font-weight: 500;
            position: sticky;
            top: 0;
            z-index: 2;
        }
        img {
            width: 100px;
            height: 60px;
            border-radius: 8px;
        }
        tr:not(:first-child).selected {
            background-color: #13508a;
            color: #FFFFFF;
        }
    </style>
</head>
<body>
    <h1>Melbourne Live TV Guide</h1>
    <table>
        <tr>
            <th>Channel</th> 
            <th> </th>
            <th>What's Playing</th>
            <th>Start Time</th>
            <th>End Time</th>
            <th>What's Up Next</th>
            <th>Start Time</th>
            <th>End Time</th>
        </tr>

        <script>
            // Function to load channel link map from 9now.txt
            async function loadChannelLinkMap() {
                try {
                    const response = await fetch('file.txt');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const channelLinkMap = await response.json();
                    return channelLinkMap;
                } catch (error) {
                    console.error('Failed to load channel links:', error);
                    return {}; // Return an empty map in case of an error
                }
            }

            async function fetchStreams() {
                try {
                    const response = await fetch('https://goddardduncan.github.io/epg/9now.txt');
                    if (!response.ok) {
                        throw new Error(`Failed to fetch stream URLs: ${response.statusText}`);
                    }
                    const allStreams = await response.json();
                    // Filter to only include the desired streams
                    return {
                        "mjh-channel-9-vic": allStreams["mjh-channel-9-vic"],
                        "mjh-gem-vic": allStreams["mjh-gem-vic"],
                        "mjh-go-vic": allStreams["mjh-go-vic"],
                        "mjh-life-vic": allStreams["mjh-life-vic"],
                        "mjh-rush-vic": allStreams["mjh-rush-vic"]
                    };
                } catch (error) {
                    console.error('Error fetching streams:', error);
                    return {};
                }
            }

            function fetchAndStoreFile(url, streamKey) {
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to fetch m3u8 file from ${url}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(m3u8Content => {
                        // Retrieve current storage or initialize as empty object
                        let storedContent = JSON.parse(localStorage.getItem('m3u8Files')) || {};

                        // Update stored content
                        storedContent[streamKey] = m3u8Content;

                        // Save back to localStorage
                        localStorage.setItem('m3u8Files', JSON.stringify(storedContent));

                        console.log('Saved m3u8 file for ' + streamKey);
                    })
                    .catch(error => {
                        console.error(error);
                    });
            }

            async function startSavingToLocalStorage() {
                try {
                    const streams = await fetchStreams();
                    let delay = 0;
                    for (let streamKey in streams) {
                        let streamUrl = streams[streamKey];
                        setTimeout(() => {
                            fetchAndStoreFile(streamUrl, streamKey);
                        }, delay);
                        delay += 2000; // Increase the delay by 2 seconds (2000 milliseconds) for each iteration
                    }

                    // Pause for 5 minutes (300000 milliseconds) after processing all streams
                    setTimeout(startSavingToLocalStorage, 300000);
                } catch (error) {
                    console.error('Error during saving to local storage:', error);
                }
            }
            async function loadChannelLinkMap() {
                try {
                    const response = await fetch('file.txt');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const channelLinkMap = await response.json();
                    return channelLinkMap;
                } catch (error) {
                    console.error('Failed to load channel links:', error);
                    return {}; // Return an empty map in case of an error
                }
            }
            // Function to initialize the TV guide
            async function initTVGuide() {
                const channelLinkMap = await loadChannelLinkMap(); // Load channel link map from file.txt

                // Start saving m3u8 files to localStorage
                startSavingToLocalStorage();

                // Rest of your existing code that uses channelLinkMap...
                let selectedRowIndex = -1;

                // Function to handle key presses
                document.addEventListener("keydown", function(event) {
                    event.preventDefault(); // Prevent default scrolling behavior
                    const tableRows = document.querySelectorAll('table tr');
                    // Check if up arrow key is pressed
                    if (event.key === "ArrowUp") {
                        if (selectedRowIndex > 0) {
                            tableRows[selectedRowIndex].classList.remove("selected");
                            selectedRowIndex--;
                            tableRows[selectedRowIndex].classList.add("selected");
                            scrollSelectedRowIntoView();
                        }
                    }
                    // Check if right arrow key is pressed
                    else if (event.key === "ArrowRight") {
                        window.location.href = "https://goddardduncan.github.io/pluto/";
                    }
                    // Check if left arrow key is pressed
                    else if (event.key === "ArrowLeft") {
                        window.location.href = "https://goddardduncan.github.io/sport/";
                    }
                    // Check if down arrow key is pressed
                    else if (event.key === "ArrowDown") {
                        if (selectedRowIndex < tableRows.length - 1) {
                            if (selectedRowIndex !== -1) {
                                tableRows[selectedRowIndex].classList.remove("selected");
                            }
                            selectedRowIndex++;
                            tableRows[selectedRowIndex].classList.add("selected");
                            scrollSelectedRowIntoView();
                        }
                    }

                    // Check if enter key is pressed
                    else if (event.key === "Enter") {
                        if (selectedRowIndex !== -1) {
                            const selectedRow = tableRows[selectedRowIndex];
                            const image = selectedRow.querySelector('img');
                            const channelLink = image.dataset.channelLink;
                            window.location.href = channelLink;

                            // Store the selected channel in localStorage
                            const channelId = image.dataset.channelId;
                            localStorage.setItem('selectedChannel', channelId);
                            localStorage.setItem('prevChannel', channelId);
                        }
                    }
                });

                // Function to scroll the selected row into view
                function scrollSelectedRowIntoView() {
                    const tableRows = document.querySelectorAll('table tr');
                    const selectedRow = tableRows[selectedRowIndex];
                    const stickyRowHeight = document.querySelector('th').offsetHeight; // Get the height of the sticky row
                    const selectedRowTop = selectedRow.getBoundingClientRect().top; // Get the top position of the selected row relative to the viewport
                    const offset = selectedRowTop - stickyRowHeight; // Calculate the offset to scroll to

                    window.scrollBy({
                        top: offset,
                        behavior: 'smooth'
                    });
                }

                const table = document.querySelector('table');

                const xmlData = "https://i.mjh.nz/au/Melbourne/epg.xml";
                const timezoneOffsetInMinutes = new Date().getTimezoneOffset();

                // Map of channel IDs to their desired names
                const channelMap = {
                    "mjh-abc-vic": "ABC",
                    "mjh-seven-mel": "Seven",
                    "mjh-7two-mel": "7two",
                    "mjh-7mate-mel": "7mate",
                    "mjh-7flix-mel": "7flix",
                    "mjh-channel-9-vic": "Channel 9",
                    "mjh-gem-vic": "9Gem",
                    "mjh-go-vic": "9Go",
                    "mjh-life-vic": "9Life",
                    "mjh-rush-vic": "9Rush",
                    "mjh-10-vic": "Channel 10",
                    "mjh-10bold-vic": "10Bold",
                    "mjh-10peach-vic": "10Peach",
                    "mjh-10shake-vic": "10Shake",
                    "mjh-sbs": "SBS",
                    "mjh-sbs-viceland": "SBS Viceland",
                    "mjh-sbs-food": "SBS Food",
                    "mjh-sbs-world-movies": "SBS World Movies",
                    "mjh-sbs-nitv": "NITV",
                    "mjh-c31": "Channel 31",
                };

                fetch(xmlData)
                    .then(response => response.text())
                    .then(str => new window.DOMParser().parseFromString(str, "text/xml"))
                    .then(data => {
                        const programs = data.getElementsByTagName("programme");
                        const currentTime = new Date();
                        currentTime.setTime(currentTime.getTime() + (timezoneOffsetInMinutes * 60 * 1000));
                        const options = { hour12: true, hour: "numeric", minute: "numeric" };

                        // Sort the channels based on their order in the channelMap
                        const sortedChannels = Object.keys(channelMap).sort((a, b) => {
                            return Object.keys(channelMap).indexOf(a) - Object.keys(channelMap).indexOf(b);
                        });

                        // Loop through the sorted channels and generate table rows accordingly
                        sortedChannels.forEach(channelID => {
                            // Find the programs associated with the current channelID
                            const channelPrograms = Array.from(programs).filter(program => program.getAttribute("channel") === channelID);

                            // Proceed with generating table rows for each program in the channelPrograms
                            channelPrograms.forEach((program, index) => { // Added 'index' to get the next program
                                // Fill the table with the channels
                                const channel = channelID;
                                const title = program.getElementsByTagName("title")[0].childNodes[0].nodeValue;
                                const start = new Date(program.getAttribute("start").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                const end = new Date(program.getAttribute("stop").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                const icon = program.getElementsByTagName("icon")[0].getAttribute("src");

                                // Map the channel ID to its desired name
                                const mappedChannel = channelMap[channel] || channel;
                                const mappedChannelLink = channelLinkMap[channel] || channel;

                                // Only show currently playing programs
                                if (currentTime >= start && currentTime <= end) {
                                    const row = document.createElement("tr");

                                    const channelCell = document.createElement("td");
                                    channelCell.appendChild(document.createTextNode(mappedChannel));
                                    row.appendChild(channelCell);

                                    const iconCell = document.createElement("td");
                                    const iconImg = document.createElement("img");
                                    iconImg.src = icon;
                                    iconImg.addEventListener("click", function() {
                                        window.location.href = mappedChannelLink;
                                        localStorage.setItem('prevChannel', channelID);
                                        localStorage.setItem('selectedChannel', channelID);
                                    });
                                    iconImg.dataset.channelLink = mappedChannelLink; // Store channel link in dataset
                                    iconImg.dataset.channelId = channel; // Store channel ID in dataset
                                    iconCell.appendChild(iconImg);
                                    row.appendChild(iconCell);

                                    const titleCell = document.createElement("td");
                                    titleCell.appendChild(document.createTextNode(title));
                                    row.appendChild(titleCell);

                                    const startCell = document.createElement("td");
                                    const adjustedStart = new Date(start.getTime() - timezoneOffsetInMinutes * 60 * 1000); // add time zone offset to the start time
                                    startCell.appendChild(document.createTextNode(adjustedStart.toLocaleTimeString("en-AU", options)));
                                    row.appendChild(startCell);

                                    const endCell = document.createElement("td");
                                    const adjustedEnd = new Date(end.getTime() - timezoneOffsetInMinutes * 60 * 1000); // add time zone offset to the end time
                                    endCell.appendChild(document.createTextNode(adjustedEnd.toLocaleTimeString("en-AU", options)));
                                    row.appendChild(endCell);

                                    // Get details of the next program
                                    const nextProgram = channelPrograms[index + 1]; // Get the next program
                                    if (nextProgram) { // Check if next program exists
                                        const Ntitle = nextProgram.getElementsByTagName("title")[0].childNodes[0].nodeValue;
                                        const Nstart = new Date(nextProgram.getAttribute("start").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                        const Nend = new Date(nextProgram.getAttribute("stop").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));

                                        // Add cells for the next show
                                        const NtitleCell = document.createElement("td");
                                        NtitleCell.appendChild(document.createTextNode(Ntitle));
                                        row.appendChild(NtitleCell);

                                        const nextStartCell = document.createElement("td");
                                        const adjustedNextStart = new Date(Nstart.getTime() - timezoneOffsetInMinutes * 60 * 1000); // add time zone offset to the start time
                                        nextStartCell.appendChild(document.createTextNode(adjustedNextStart.toLocaleTimeString("en-AU", options)));
                                        row.appendChild(nextStartCell);

                                        const nextEndCell = document.createElement("td");
                                        const adjustedNextEnd = new Date(Nend.getTime() - timezoneOffsetInMinutes * 60 * 1000); // add time zone offset to the start time
                                        nextEndCell.appendChild(document.createTextNode(adjustedNextEnd.toLocaleTimeString("en-AU", options)));
                                        row.appendChild(nextEndCell);
                                    }

                                    table.appendChild(row);
                                }
                            });
                        });

                        // Highlight the first row initially
                        table.querySelector('tr').classList.add("selected");
                        selectedRowIndex = 0;
                        scrollSelectedRowIntoView();

                        // Check if there's a previously selected channel stored in localStorage
                        const storedChannel = localStorage.getItem('selectedChannel');
                        if (storedChannel) {
                            // Find the row corresponding to the stored channel and select it
                            const storedChannelRow = table.querySelector(`img[data-channel-id="${storedChannel}"]`).parentNode.parentNode;
                            const rows = table.querySelectorAll('tr');
                            rows.forEach((row, index) => {
                                if (row === storedChannelRow) {
                                    row.classList.add("selected");
                                    selectedRowIndex = index;
                                }
                            });
                            scrollSelectedRowIntoView();
                        }
                    });

                // Wake lock implementation
                let wakeLock = null;

                const requestWakeLock = async () => {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Screen wake lock is active');
                    } catch (err) {
                        console.error(`${err.name}, ${err.message}`);
                    }
                };

                const handleVisibilityChange = () => {
                    if (wakeLock !== null && document.visibilityState === 'visible') {
                        requestWakeLock();
                    }
                };

                document.addEventListener('visibilitychange', handleVisibilityChange);

                // Request a wake lock
                requestWakeLock();
            }

            // Initialize the TV guide
            initTVGuide();
        </script>
    </table>
    <script>
        document.addEventListener("DOMContentLoaded", function(event) {
            // Function to show buttons on mobile devices
            function displayButtonsOnMobile() {
                var screenWidth = window.innerWidth;
                var mobileButtonsDiv = document.getElementById("mobileButtons");
                
                // Adjust the max-width value as per your requirement
                if (screenWidth <= 1024) {
                    mobileButtonsDiv.style.display = "block";
                } else {
                    mobileButtonsDiv.style.display = "none";
                }
            }

            // Call the function on initial load
            displayButtonsOnMobile();

            // Optionally, call this function on window resize if you want to handle dynamic resizing
            window.onresize = displayButtonsOnMobile;
        });
    </script>
    <!-- Mobile-specific buttons -->
    <div id="mobileButtons" style="text-align: center; margin-top: 20px; display: none;">
        <button onclick="window.location.href = 'https://goddardduncan.github.io/sport/';">Sport</button>
        <button onclick="window.location.href = 'https://goddardduncan.github.io/pluto/';">Pluto</button>
        <button onclick="window.location.href = 'https://goddardduncan.github.io/tvcast/';">ChromeCast</button>
    </div>
</body>
</html>
