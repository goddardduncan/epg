<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="https://goddardduncan.github.io/epg/favicon.ico" type="image/x-icon">
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="300">
    <title>Melbourne Live TV Guide</title>
    <style>
        body {
            background-color: #1e2d3b;
            color: #d4d4d4;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        h1 {
            text-align: center;
            font-size: 36px;
            margin: 20px 0;
            color: #4f5e80;
        }
        table {
            border-collapse: collapse;
            margin: 20px auto;
            width: 95%;
            max-width: 1200px;
            background-color: #263544;
            border-radius: 8px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #33475b;
        }
        th {
            background-color: #33475b;
            color: #ffffff;
            font-size: 18px;
            font-weight: 500;
            position: sticky;
            top: 0;
            z-index: 2;
        }
        img {
            width: 100px;
            height: 60px;
            border-radius: 8px;
        }
        tr:not(:first-child).selected {
            background-color: #13508a;
            color: #FFFFFF;
        }
    </style>
</head>
<body>
    <h1>Melbourne Live TV Guide</h1>
    <table>
        <tr>
            <th>Channel</th> 
            <th> </th>
            <th>What's Playing</th>
            <th>Start Time</th>
            <th>End Time</th>
            <th>What's Up Next</th>
            <th>Start Time</th>
            <th>End Time</th>
        </tr>

        <script>
            async function loadChannelOrder() {
                try {
                    const response = await fetch('channelorder.json');
                    if (!response.ok) {
                        throw new Error(`Failed to fetch channel order: ${response.statusText}`);
                    }
                    const channelData = await response.json();
                    const channelOrder = channelData.map(item => item.id); // Extract channel IDs for order
                    const channelMap = Object.fromEntries(channelData.map(item => [item.id, item.name])); // Create map from JSON data
                    const channelLinkMap = Object.fromEntries(channelData.map(item => [item.id, item.link])); // Extract links if available
                    return { channelOrder, channelMap, channelLinkMap };
                } catch (error) {
                    console.error('Error loading channel order:', error);
                    return { channelOrder: [], channelMap: {}, channelLinkMap: {} };
                }
            }

            async function fetchStreams() {
                try {
                    const response = await fetch('https://goddardduncan.github.io/epg/9now.json');
                    if (!response.ok) {
                        throw new Error(`Failed to fetch stream URLs: ${response.statusText}`);
                    }
                    const allStreams = await response.json();
                    // Filter to only include the desired streams
                    return {
                        "mjh-channel-9-vic": allStreams["mjh-channel-9-vic"],
                        "mjh-gem-vic": allStreams["mjh-gem-vic"],
                        "mjh-go-vic": allStreams["mjh-go-vic"],
                        "mjh-life-vic": allStreams["mjh-life-vic"],
                        "mjh-rush-vic": allStreams["mjh-rush-vic"]
                    };
                } catch (error) {
                    console.error('Error fetching streams:', error);
                    return {};
                }
            }

            function fetchAndStoreFile(url, streamKey) {
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to fetch m3u8 file from ${url}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(m3u8Content => {
                        // Retrieve current storage or initialize as empty object
                        let storedContent = JSON.parse(localStorage.getItem('m3u8Files')) || {};

                        // Update stored content
                        storedContent[streamKey] = m3u8Content;

                        // Save back to localStorage
                        localStorage.setItem('m3u8Files', JSON.stringify(storedContent));

                        console.log('Saved m3u8 file for ' + streamKey);
                    })
                    .catch(error => {
                        console.error(error);
                    });
            }

            async function startSavingToLocalStorage() {
                try {
                    const streams = await fetchStreams();
                    let delay = 0;
                    for (let streamKey in streams) {
                        let streamUrl = streams[streamKey];
                        setTimeout(() => {
                            fetchAndStoreFile(streamUrl, streamKey);
                        }, delay);
                        delay += 1000; // Increase the delay by 1 second (1000 milliseconds) for each iteration
                    }

                    // Pause for 5 minutes (100000 milliseconds) after processing all streams
                    setTimeout(startSavingToLocalStorage, 100000);
                } catch (error) {
                    console.error('Error during saving to local storage:', error);
                }
            }

            async function initTVGuide() {
                const { channelOrder, channelMap, channelLinkMap } = await loadChannelOrder();
                
                // Start saving m3u8 files to localStorage
                startSavingToLocalStorage();

                let selectedRowIndex = -1;

                document.addEventListener("keydown", function(event) {
                    event.preventDefault();
                    const tableRows = document.querySelectorAll('table tr');
                    if (event.key === "ArrowUp") {
                        if (selectedRowIndex > 0) {
                            tableRows[selectedRowIndex].classList.remove("selected");
                            selectedRowIndex--;
                            tableRows[selectedRowIndex].classList.add("selected");
                            scrollSelectedRowIntoView();
                        }
                    } else if (event.key === "ArrowRight") {
                        window.location.href = "https://goddardduncan.github.io/pluto/";
                    } else if (event.key === "ArrowLeft") {
                        window.location.href = "https://goddardduncan.github.io/sport/";
                    } else if (event.key === "ArrowDown") {
                        if (selectedRowIndex < tableRows.length - 1) {
                            if (selectedRowIndex !== -1) {
                                tableRows[selectedRowIndex].classList.remove("selected");
                            }
                            selectedRowIndex++;
                            tableRows[selectedRowIndex].classList.add("selected");
                            scrollSelectedRowIntoView();
                        }
                    } else if (event.key === "Enter") {
                        if (selectedRowIndex !== -1) {
                            const selectedRow = tableRows[selectedRowIndex];
                            const image = selectedRow.querySelector('img');
                            const channelLink = image.dataset.channelLink;
                            window.location.href = channelLink;

                            const channelId = image.dataset.channelId;
                            localStorage.setItem('selectedChannel', channelId);
                            localStorage.setItem('prevChannel', channelId);
                        }
                    }
                });

                function scrollSelectedRowIntoView() {
                    const tableRows = document.querySelectorAll('table tr');
                    const selectedRow = tableRows[selectedRowIndex];
                    const stickyRowHeight = document.querySelector('th').offsetHeight;
                    const selectedRowTop = selectedRow.getBoundingClientRect().top;
                    const offset = selectedRowTop - stickyRowHeight;

                    window.scrollBy({
                        top: offset,
                        behavior: 'smooth'
                    });
                }

                const table = document.querySelector('table');

                const xmlData = "https://i.mjh.nz/au/Melbourne/epg.xml";
                const timezoneOffsetInMinutes = new Date().getTimezoneOffset();

                fetch(xmlData)
                    .then(response => response.text())
                    .then(str => new window.DOMParser().parseFromString(str, "text/xml"))
                    .then(data => {
                        const programs = data.getElementsByTagName("programme");
                        const currentTime = new Date();
                        currentTime.setTime(currentTime.getTime() + (timezoneOffsetInMinutes * 60 * 1000));
                        const options = { hour12: true, hour: "numeric", minute: "numeric" };

                        // Loop through the channels in the order specified in channelOrder
                        channelOrder.forEach(channelID => {
                            const channelPrograms = Array.from(programs).filter(program => program.getAttribute("channel") === channelID);

                            channelPrograms.forEach((program, index) => {
                                const channel = channelID;
                                const title = program.getElementsByTagName("title")[0].childNodes[0].nodeValue;
                                const start = new Date(program.getAttribute("start").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                const end = new Date(program.getAttribute("stop").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                const icon = program.getElementsByTagName("icon")[0].getAttribute("src");

                                const mappedChannel = channelMap[channel] || channel;

                                if (currentTime >= start && currentTime <= end) {
                                    const row = document.createElement("tr");

                                    const channelCell = document.createElement("td");
                                    channelCell.appendChild(document.createTextNode(mappedChannel));
                                    row.appendChild(channelCell);

                                    const iconCell = document.createElement("td");
                                    const iconImg = document.createElement("img");
                                    iconImg.src = icon;
                                    iconImg.addEventListener("click", function() {
                                        window.location.href = channelLinkMap[channel];
                                        localStorage.setItem('prevChannel', channelID);
                                        localStorage.setItem('selectedChannel', channelID);
                                    });
                                    iconImg.dataset.channelLink = channelLinkMap[channel];
                                    iconImg.dataset.channelId = channel;
                                    iconCell.appendChild(iconImg);
                                    row.appendChild(iconCell);

                                    const titleCell = document.createElement("td");
                                    titleCell.appendChild(document.createTextNode(title));
                                    row.appendChild(titleCell);

                                    const startCell = document.createElement("td");
                                    const adjustedStart = new Date(start.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                    startCell.appendChild(document.createTextNode(adjustedStart.toLocaleTimeString("en-AU", options)));
                                    row.appendChild(startCell);

                                    const endCell = document.createElement("td");
                                    const adjustedEnd = new Date(end.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                    endCell.appendChild(document.createTextNode(adjustedEnd.toLocaleTimeString("en-AU", options)));
                                    row.appendChild(endCell);

                                    const nextProgram = channelPrograms[index + 1];
                                    if (nextProgram) {
                                        const Ntitle = nextProgram.getElementsByTagName("title")[0].childNodes[0].nodeValue;
                                        const Nstart = new Date(nextProgram.getAttribute("start").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));
                                        const Nend = new Date(nextProgram.getAttribute("stop").replace(" +0000", "").replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, "$1-$2-$3T$4:$5:$6"));

                                        const NtitleCell = document.createElement("td");
                                        NtitleCell.appendChild(document.createTextNode(Ntitle));
                                        row.appendChild(NtitleCell);

                                        const nextStartCell = document.createElement("td");
                                        const adjustedNextStart = new Date(Nstart.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                        nextStartCell.appendChild(document.createTextNode(adjustedNextStart.toLocaleTimeString("en-AU", options)));
                                        row.appendChild(nextStartCell);

                                        const nextEndCell = document.createElement("td");
                                        const adjustedNextEnd = new Date(Nend.getTime() - timezoneOffsetInMinutes * 60 * 1000);
                                        nextEndCell.appendChild(document.createTextNode(adjustedNextEnd.toLocaleTimeString("en-AU", options)));
                                        row.appendChild(nextEndCell);
                                    }

                                    table.appendChild(row);
                                }
                            });
                        });

                        table.querySelector('tr').classList.add("selected");
                        selectedRowIndex = 0;
                        scrollSelectedRowIntoView();

                        const storedChannel = localStorage.getItem('selectedChannel');
                        if (storedChannel) {
                            const storedChannelRow = table.querySelector(`img[data-channel-id="${storedChannel}"]`).parentNode.parentNode;
                            const rows = table.querySelectorAll('tr');
                            rows.forEach((row, index) => {
                                if (row === storedChannelRow) {
                                    row.classList.add("selected");
                                    selectedRowIndex = index;
                                }
                            });
                            scrollSelectedRowIntoView();
                        }
                    });

                let wakeLock = null;

                const requestWakeLock = async () => {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Screen wake lock is active');
                    } catch (err) {
                        console.error(`${err.name}, ${err.message}`);
                    }
                };

                const handleVisibilityChange = () => {
                    if (wakeLock !== null && document.visibilityState === 'visible') {
                        requestWakeLock();
                    }
                };

                document.addEventListener('visibilitychange', handleVisibilityChange);
                requestWakeLock();
            }

            initTVGuide();
        </script>
    </table>
    <script>
        document.addEventListener("DOMContentLoaded", function(event) {
            function displayButtonsOnMobile() {
                var screenWidth = window.innerWidth;
                var mobileButtonsDiv = document.getElementById("mobileButtons");
                if (screenWidth <= 1024) {
                    mobileButtonsDiv.style.display = "block";
                } else {
                    mobileButtonsDiv.style.display = "none";
                }
            }
            displayButtonsOnMobile();
            window.onresize = displayButtonsOnMobile;
        });
    </script>
    <div id="mobileButtons" style="text-align: center; margin-top: 20px; display: none;">
        <button onclick="window.location.href = 'https://goddardduncan.github.io/sport/';">Sport</button>
        <button onclick="window.location.href = 'https://goddardduncan.github.io/pluto/';">Pluto</button>
        <button onclick="window.location.href = 'https://goddardduncan.github.io/tvcast/';">ChromeCast</button>
    </div>
</body>
</html>
